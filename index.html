<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amalgamation Tower Defence</title>
    <style>
        :root {
            --bg-color: #0d1117;
            --ui-bg: rgba(22, 27, 34, 0.95);
            --accent-tech: #00f3ff;
            --accent-magic: #bd00ff;
            --text-color: #c9d1d9;
            --gold: #ffd700;
            --danger: #ff4444;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            user-select: none;
            display: flex;
            flex-direction: column;
        }

        /* Main Grid Layout */
        #app-layout {
            display: grid;
            grid-template-areas:
                "header header header"
                "left   game   right"
                "footer footer footer";
            grid-template-columns: 120px 1fr 220px;
            grid-template-rows: 60px 1fr 80px;
            height: 100%;
            width: 100%;
        }

        /* Header (Stats) */
        #header-panel {
            grid-area: header;
            background: var(--ui-bg);
            border-bottom: 1px solid #30363d;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 40px;
            font-size: 20px;
            font-weight: bold;
            z-index: 10;
        }
        
        .stat-box { display: flex; align-items: center; gap: 10px; }
        .stat-icon { font-family: 'Courier New', monospace; font-size: 24px; }
        .currency { color: var(--gold); }
        .lives { color: var(--danger); }
        .wave { color: var(--accent-tech); }
        .wave.endless { color: #ffd700; text-shadow: 0 0 5px #ffd700; }

        /* Left Panel (Abilities) */
        #left-panel {
            grid-area: left;
            background: var(--ui-bg);
            border-right: 1px solid #30363d;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            gap: 15px;
            z-index: 10;
        }

        .panel-label {
            font-size: 12px;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
            text-align: center;
            width: 100%;
            border-bottom: 1px solid #30363d;
            padding-bottom: 5px;
        }

        .ability-btn {
            width: 100%;
            height: 80px;
            background: #21262d;
            border: 1px solid #30363d;
            border-radius: 6px;
            cursor: pointer;
            color: white;
            position: relative;
            overflow: hidden;
            transition: 0.2s;
            font-size: 11px;
            font-weight: bold;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 5px;
        }
        .ability-btn:hover:not(:disabled) { border-color: var(--accent-tech); background: #30363d; }
        .ability-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .ability-btn span { z-index: 2; }
        
        .cooldown-overlay {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 0%;
            background: rgba(0, 0, 0, 0.7); transition: height 0.1s linear; z-index: 1;
        }

        /* Right Panel (Shop) */
        #right-panel {
            grid-area: right;
            background: var(--ui-bg);
            border-left: 1px solid #30363d;
            display: flex;
            flex-direction: column;
            padding: 10px;
            z-index: 10;
            overflow: hidden; /* Container handles overflow */
        }
        
        #shop-list {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding-right: 5px; /* space for scrollbar */
        }

        .tower-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #444;
            border-radius: 4px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            gap: 2px;
            position: relative;
            min-height: 60px;
        }
        .tower-card:hover { border-color: var(--accent-tech); background: rgba(0, 243, 255, 0.1); }
        .tower-card.selected { border-color: var(--gold); background: rgba(255, 215, 0, 0.15); box-shadow: 0 0 10px rgba(255, 215, 0, 0.3); }
        .tower-card.too-expensive { opacity: 0.5; border-color: #552222; }
        
        .tower-name { font-weight: bold; font-size: 13px; color: #fff; }
        .tower-cost { font-size: 12px; color: var(--gold); }
        .tower-desc { font-size: 10px; color: #8b949e; }
        .hotkey-hint { position: absolute; top: 5px; right: 5px; font-size: 10px; color: #555; font-family: monospace; border: 1px solid #333; padding: 1px 4px; border-radius: 3px; background: rgba(0,0,0,0.5); }

        /* Footer (Controls) */
        #footer-panel {
            grid-area: footer;
            background: var(--ui-bg);
            border-top: 1px solid #30363d;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            z-index: 10;
        }

        .control-btn {
            padding: 12px 24px;
            background: #21262d;
            border: 1px solid #30363d;
            color: white;
            font-weight: bold;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            min-width: 120px;
            text-align: center;
            transition: all 0.2s;
        }
        .control-btn:hover { background: #30363d; border-color: #8b949e; }
        
        #start-wave-btn {
            background: linear-gradient(45deg, var(--accent-tech), var(--accent-magic));
            border: none;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
        }
        #start-wave-btn:hover { filter: brightness(1.2); }
        .auto-on { background: #238636 !important; border-color: #2ea043 !important; }

        /* Game Area */
        #game-area {
            grid-area: game;
            position: relative;
            background: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            background: radial-gradient(circle at center, #1a1f2e 0%, #0d1117 100%);
            max-width: 100%;
            max-height: 100%;
            object-fit: contain; /* Ensures aspect ratio */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        /* Modals (Upgrade, Map Select, Game Over) */
        #upgrade-modal {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            background: rgba(22, 27, 34, 0.98);
            border: 1px solid #30363d;
            padding: 15px;
            border-radius: 8px;
            display: none;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
        }

        .upgrade-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #444; padding-bottom: 5px; }
        .upgrade-paths { display: flex; gap: 10px; }
        .path-column { flex: 1; background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 4px; border: 1px solid #333; }
        .path-tech { border-color: rgba(0, 243, 255, 0.3); }
        .path-magic { border-color: rgba(189, 0, 255, 0.3); }
        .path-title { font-size: 12px; text-transform: uppercase; margin-bottom: 8px; text-align: center; }
        .path-tech .path-title { color: var(--accent-tech); }
        .path-magic .path-title { color: var(--accent-magic); }
        
        .upgrade-btn {
            width: 100%; padding: 8px; background: #21262d; border: 1px solid #30363d;
            color: white; cursor: pointer; border-radius: 4px; margin-top: 5px; font-size: 12px;
        }
        .upgrade-btn:hover:not(:disabled) { background: #30363d; }
        .upgrade-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .sell-btn { background: #3d1c1c; border: 1px solid #ff4444; color: #ffaaaa; margin-top: 10px; }
        
        #priority-btn {
            background: #238636; border: 1px solid #2ea043; margin-left: 10px;
            font-size: 11px; padding: 4px 8px; border-radius: 4px; color: white; cursor: pointer;
        }
        
        #dps-display { color: #f0f6fc; font-size: 12px; margin-left: 10px; }

        /* Fullscreen Overlays */
        #map-screen, #game-over, #level-complete {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(13, 17, 23, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 200;
        }
        #game-over { display: none; }
        #level-complete { display: none; }

        .map-grid { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; max-width: 900px; }
        .map-card {
            width: 200px; height: 160px; background: #161b22; border: 1px solid #30363d;
            border-radius: 8px; cursor: pointer; padding: 15px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: 0.3s; position: relative;
        }
        .map-card:hover:not(.locked) { transform: translateY(-5px); border-color: var(--accent-tech); box-shadow: 0 5px 15px rgba(0, 243, 255, 0.2); }
        .map-card.locked { opacity: 0.5; cursor: not-allowed; border-color: #3d1c1c; }
        .map-name { font-size: 18px; font-weight: bold; margin-bottom: 5px; color: #fff; text-align: center; }
        .map-diff { font-size: 12px; color: #8b949e; margin-bottom: 5px; }
        .map-preview { width: 100%; height: 60px; background: #0d1117; margin-top: 10px; border-radius: 4px; opacity: 0.5; }
        .lock-icon { font-size: 24px; color: #8b949e; margin-top: 10px; }
        
        h1 { margin: 0 0 20px 0; text-shadow: 0 0 10px var(--accent-magic); font-size: 32px; }
        .modal-buttons { display: flex; gap: 20px; margin-top: 20px; }

    </style>
</head>
<body>

    <div id="app-layout">
        <!-- Header -->
        <div id="header-panel">
            <div class="stat-box"><span class="stat-icon currency">Ψ</span><span id="money-display">300</span></div>
            <div class="stat-box"><span class="stat-icon lives">♥</span><span id="lives-display">100</span></div>
            <div class="stat-box"><span class="stat-icon wave">WAVE</span><span id="wave-display">1</span></div>
        </div>

        <!-- Left Sidebar (Abilities) -->
        <div id="left-panel">
            <div class="panel-label">Abilities</div>
            <button id="ability-laser" class="ability-btn" onclick="activateAbility('laser')">
                <span>ORBITAL LASER</span>
                <div id="cd-laser" class="cooldown-overlay"></div>
            </button>
            <button id="ability-freeze" class="ability-btn" onclick="activateAbility('freeze')">
                <span>TIME FREEZE</span>
                <div id="cd-freeze" class="cooldown-overlay"></div>
            </button>
        </div>

        <!-- Game Area -->
        <div id="game-area">
            <canvas id="gameCanvas" width="1000" height="600"></canvas>
            
            <!-- Floating Upgrade Modal (Centered over canvas) -->
            <div id="upgrade-modal">
                <div class="upgrade-header">
                    <div>
                        <span id="selected-tower-name">Tower Name</span>
                        <span id="dps-display">Dmg: 0</span>
                        <button id="priority-btn" onclick="cyclePriority()">Target: First</button>
                    </div>
                    <button class="upgrade-btn" style="width: auto; padding: 2px 8px;" onclick="closeUpgradeMenu()">X</button>
                </div>
                <div class="upgrade-paths">
                    <div class="path-column path-tech">
                        <div class="path-title">Science / Tech</div>
                        <div id="path-1-desc" style="font-size: 11px; height: 30px; margin-bottom: 5px;">Upgrade Desc</div>
                        <button id="btn-upgrade-1" class="upgrade-btn" onclick="buyUpgrade(1)">Upgrade (Ψ <span id="cost-1">0</span>)</button>
                    </div>
                    <div class="path-column path-magic">
                        <div class="path-title">Arcane / Magic</div>
                        <div id="path-2-desc" style="font-size: 11px; height: 30px; margin-bottom: 5px;">Upgrade Desc</div>
                        <button id="btn-upgrade-2" class="upgrade-btn" onclick="buyUpgrade(2)">Upgrade (Ψ <span id="cost-2">0</span>)</button>
                    </div>
                </div>
                <button class="upgrade-btn sell-btn" onclick="sellSelectedTower()">Sell Tower (Ψ <span id="sell-value">0</span>)</button>
            </div>
        </div>

        <!-- Right Sidebar (Constructs / Shop) -->
        <div id="right-panel">
            <div class="panel-label">Constructs</div>
            <div id="shop-list">
                <div id="card-miner" class="tower-card" onclick="selectTowerToBuild('miner', this)">
                    <span class="hotkey-hint">1</span>
                    <div class="tower-name">Data-Mine</div><div class="tower-cost">Ψ 150</div><div class="tower-desc">Passive Income.</div>
                </div>
                <div id="card-sentry" class="tower-card" onclick="selectTowerToBuild('sentry', this)">
                    <span class="hotkey-hint">2</span>
                    <div class="tower-name">Quantum Sentry</div><div class="tower-cost">Ψ 250</div><div class="tower-desc">Rapid Kinetic Fire.</div>
                </div>
                 <div id="card-vent" class="tower-card" onclick="selectTowerToBuild('vent', this)">
                    <span class="hotkey-hint">3</span>
                    <div class="tower-name">Flux Vent</div><div class="tower-cost">Ψ 300</div><div class="tower-desc">Short Range AoE.</div>
                </div>
                <div id="card-pylon" class="tower-card" onclick="selectTowerToBuild('pylon', this)">
                    <span class="hotkey-hint">4</span>
                    <div class="tower-name">Chrono-Pylon</div><div class="tower-cost">Ψ 350</div><div class="tower-desc">Buffs Towers.</div>
                </div>
                <div id="card-prism" class="tower-card" onclick="selectTowerToBuild('prism', this)">
                    <span class="hotkey-hint">5</span>
                    <div class="tower-name">Aether Prism</div><div class="tower-cost">Ψ 400</div><div class="tower-desc">Energy Beam.</div>
                </div>
                 <div id="card-coil" class="tower-card" onclick="selectTowerToBuild('coil', this)">
                    <span class="hotkey-hint">6</span>
                    <div class="tower-name">Tesla Coil</div><div class="tower-cost">Ψ 450</div><div class="tower-desc">Chain Lightning.</div>
                </div>
                <div id="card-lance" class="tower-card" onclick="selectTowerToBuild('lance', this)">
                    <span class="hotkey-hint">7</span>
                    <div class="tower-name">Void Lance</div><div class="tower-cost">Ψ 500</div><div class="tower-desc">Sniper.</div>
                </div>
                <div id="card-fabricator" class="tower-card" onclick="selectTowerToBuild('fabricator', this)">
                    <span class="hotkey-hint">8</span>
                    <div class="tower-name">Fabricator</div><div class="tower-cost">Ψ 550</div><div class="tower-desc">Places Mines.</div>
                </div>
                <div id="card-mortar" class="tower-card" onclick="selectTowerToBuild('mortar', this)">
                    <span class="hotkey-hint">9</span>
                    <div class="tower-name">Gravity Mortar</div><div class="tower-cost">Ψ 600</div><div class="tower-desc">Long Range Splash.</div>
                </div>
                <div id="card-nullifier" class="tower-card" onclick="selectTowerToBuild('nullifier', this)">
                    <span class="hotkey-hint">0</span>
                    <div class="tower-name">Nullifier</div><div class="tower-cost">Ψ 700</div><div class="tower-desc">Strips Resistances.</div>
                </div>
            </div>
        </div>

        <!-- Footer (Controls) -->
        <div id="footer-panel">
            <button id="start-wave-btn" class="control-btn" onclick="startNextWave()">START WAVE</button>
            <button id="auto-btn" class="control-btn" onclick="toggleAutoStart()">Auto: OFF</button>
            <button id="speed-btn" class="control-btn" onclick="toggleSpeed()">Speed: 1x</button>
        </div>

        <!-- Overlays -->
        <div id="map-screen">
            <h1>AMALGAMATION CAMPAIGN</h1>
            <div class="map-grid" id="map-grid-container"></div>
        </div>

        <div id="level-complete">
            <h1 style="color: var(--gold);">SECTOR SECURED</h1>
            <p style="font-size: 24px; color: #fff;">All hostiles neutralized.</p>
            <div class="modal-buttons">
                <button class="control-btn" onclick="returnToMenu()">Menu</button>
                <button class="control-btn" style="border-color: var(--gold); color: var(--gold);" onclick="continueEndless()">Endless Mode</button>
            </div>
        </div>

        <div id="game-over">
            <h1 style="color: #ff4444;">SYSTEM FAILURE</h1>
            <p style="font-size: 24px; color: #fff;">The core has been breached.</p>
            <div class="modal-buttons">
                <button class="control-btn" onclick="location.reload()">Reboot System</button>
            </div>
        </div>

    </div>

<script>
const CANVAS_WIDTH = 1000;
const CANVAS_HEIGHT = 600;
const GRID_SIZE = 40;

const C_PATH = "#262c36";
const C_PATH_BORDER = "#30363d";
const C_RANGE = "rgba(255, 255, 255, 0.1)";
const C_RANGE_BORDER = "rgba(255, 255, 255, 0.3)";

// Audio Context (Initialized on user interaction)
let audioCtx;
const Sound = {
    init: () => {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    },
    play: (type) => {
        if (!audioCtx) return;
        if (audioCtx.state === 'suspended') audioCtx.resume();
        
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        const now = audioCtx.currentTime;
        
        if (type === 'shoot_tech') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
        } else if (type === 'shoot_magic') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(1200, now + 0.2);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
        } else if (type === 'explosion') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.exponentialRampToValueAtTime(10, now + 0.3);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
            osc.start(now);
            osc.stop(now + 0.3);
        } else if (type === 'laser') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, now);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
            osc.start(now);
            osc.stop(now + 0.5);
        } else if (type === 'freeze') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(1000, now);
            osc.frequency.linearRampToValueAtTime(100, now + 1.0);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0.001, now + 1.0);
            osc.start(now);
            osc.stop(now + 1.0);
        }
    }
};

// Maps
const MAPS = [
    {
        name: "Sector Alpha", diffName: "Normal",
        points: [{x: 0, y: 100}, {x: 200, y: 100}, {x: 200, y: 400}, {x: 400, y: 400}, {x: 400, y: 200}, {x: 700, y: 200}, {x: 700, y: 500}, {x: 900, y: 500}, {x: 900, y: 300}, {x: 1000, y: 300}],
        difficultyMod: 1.0, waveLimit: 50, color: "#00f3ff",
        previewStyle: "background: linear-gradient(45deg, transparent 45%, #00f3ff 45%, #00f3ff 55%, transparent 55%);"
    },
    {
        name: "The Canyon", diffName: "Hard",
        points: [{x: 0, y: 150}, {x: 800, y: 150}, {x: 800, y: 450}, {x: 200, y: 450}, {x: 200, y: 300}, {x: 1000, y: 300}],
        difficultyMod: 1.2, waveLimit: 75, color: "#bd00ff",
        previewStyle: "background: linear-gradient(90deg, transparent 45%, #bd00ff 45%, #bd00ff 55%, transparent 55%);"
    },
    {
        name: "Void Spiral", diffName: "Expert",
        points: [{x: 500, y: 0}, {x: 500, y: 200}, {x: 700, y: 200}, {x: 700, y: 400}, {x: 300, y: 400}, {x: 300, y: 300}, {x: 500, y: 300}, {x: 500, y: 600}],
        difficultyMod: 1.5, waveLimit: 100, color: "#ffd700",
        previewStyle: "border-radius: 50%; border: 2px solid #ffd700;"
    },
    {
        name: "Zig-Zag Zone", diffName: "Chaos",
        points: [{x:0,y:50}, {x:200,y:550}, {x:400,y:50}, {x:600,y:550}, {x:800,y:50}, {x:1000,y:550}],
        difficultyMod: 1.8, waveLimit: 125, color: "#ff4444",
        previewStyle: "background: repeating-linear-gradient(45deg, #333, #333 10px, #444 10px, #444 20px);"
    }
];

// Enemies
const ENEMIES = {
    basic: { hp: 20, speed: 2, color: "#a8b5c2", reward: 5, radius: 8, name: "Drone", shape: "circle", resistance: "none" },
    swarm: { hp: 5, speed: 5, color: "#ff00ff", reward: 2, radius: 5, name: "Nano-Swarm", shape: "triangle_small", resistance: "none" },
    fast: { hp: 15, speed: 3.5, color: "#00f3ff", reward: 8, radius: 7, name: "Glitch-Runner", shape: "arrow", resistance: "none" },
    tank: { hp: 120, speed: 1, color: "#6e7681", reward: 15, radius: 14, name: "Heavy Mech", shape: "square", resistance: "physical" }, 
    diamond: { hp: 500, speed: 1.2, color: "#00ffff", reward: 60, radius: 14, name: "Diamond Construct", shape: "diamond_solid", resistance: "physical" },
    dark_matter: { hp: 400, speed: 3.0, color: "#111111", reward: 70, radius: 12, name: "Dark Matter Wisp", shape: "star_dark", resistance: "energy" },
    elite: { hp: 600, speed: 1.5, color: "#DC143C", reward: 50, radius: 12, name: "Praetorian", shape: "diamond", resistance: "none" },
    regen: { hp: 200, speed: 1.8, color: "#32CD32", reward: 25, radius: 10, name: "Regenerator", shape: "cross", resistance: "none" },
    phase: { hp: 100, speed: 2.5, color: "#8A2BE2", reward: 35, radius: 9, name: "Phase-Shifter", shape: "star_4", resistance: "none" },
    centurion: { hp: 1000, speed: 1.2, color: "#FF8C00", reward: 100, radius: 18, name: "Flux Centurion", shape: "star_6", resistance: "physical" }, 
    boss: { hp: 3000, speed: 0.6, color: "#bd00ff", reward: 300, radius: 25, name: "Void Titan", shape: "skull", resistance: "none" }, 
    titan_mk2: { hp: 10000, speed: 0.4, color: "#fff", reward: 1000, radius: 35, name: "Omega Titan", shape: "omega", resistance: "all" },
    flyer: { hp: 80, speed: 3.0, color: "#FF4500", reward: 20, radius: 9, name: "Wrinkling", shape: "wing", resistance: "none", fly: true }
};

// Tower Definitions
const TOWER_TYPES = {
    miner: { name: "Data-Mine", cost: 150, range: 0, damage: 0, cooldown: 0, color: "#4CAF50", shape: "square", type: "none", desc: "Generates Ψ 15 per wave.", upgrades: { path1: [{ name: "Overclock", cost: 100, desc: "+10 Cash" }, { name: "Crypto Farm", cost: 300, desc: "+25 Cash" }, { name: "Blockchain AI", cost: 800, desc: "+10% Interest" }, { name: "Server Farm", cost: 2000, desc: "+150 Cash" }, { name: "Quantum Market", cost: 5000, desc: "+20% Interest" }], path2: [{ name: "Alchemy", cost: 150, desc: "Kill Cash +1" }, { name: "Transmute", cost: 400, desc: "+40 Cash" }, { name: "Philosopher Stone", cost: 1000, desc: "+100 Cash" }, { name: "Golden Age", cost: 2500, desc: "Base Gen x2" }, { name: "Midas Curse", cost: 6000, desc: "Kill Cash +5" }] } },
    sentry: { name: "Quantum Sentry", cost: 250, range: 120, damage: 10, cooldown: 30, color: "#00a8f3", shape: "square", projectileSpeed: 8, type: "physical", desc: "Rapid fire kinetic.", upgrades: { path1: [{ name: "Accelerator", cost: 150, desc: "Faster Fire" }, { name: "Pierce", cost: 400, desc: "Hits 2 targets" }, { name: "Railgun", cost: 1200, desc: "Fast & High Dmg" }, { name: "Gatling", cost: 2500, desc: "Insane Fire Rate" }, { name: "Death Ray", cost: 6000, desc: "Instant Hit Beam" }], path2: [{ name: "Rune Carving", cost: 150, desc: "+5 Damage" }, { name: "Seeking", cost: 350, desc: "Auto-aim" }, { name: "Multi-Shot", cost: 1000, desc: "Fires 3 bolts" }, { name: "Spell Weaver", cost: 2200, desc: "Double Projectiles" }, { name: "Eldritch Blast", cost: 5500, desc: "Explosive Magic" }] } },
    vent: { name: "Flux Vent", cost: 300, range: 80, damage: 1, cooldown: 6, color: "#FF4500", shape: "triangle", projectileSpeed: 0, type: "energy", desc: "Short range AoE spray.", upgrades: { path1: [{ name: "High Pressure", cost: 200, desc: "+Range" }, { name: "Plasma Fire", cost: 450, desc: "+Damage" }, { name: "Blue Flame", cost: 1100, desc: "Melts Armor" }, { name: "Fusion Core", cost: 2400, desc: "Massive Cone" }, { name: "Solar Wind", cost: 5000, desc: "Global DoT Aura" }], path2: [{ name: "Cursed Fumes", cost: 250, desc: "Slows enemies" }, { name: "Hex Cloud", cost: 500, desc: "Reduces Dmg Dealt" }, { name: "Soul Burn", cost: 1200, desc: "% Max HP Dmg" }, { name: "Terror", cost: 2600, desc: "Stuns briefly" }, { name: "Nether Rift", cost: 5500, desc: "Insta-kill low HP" }] } },
    coil: { name: "Tesla Coil", cost: 450, range: 130, damage: 15, cooldown: 45, color: "#00FFFF", shape: "circle", projectileSpeed: 0, type: "energy", desc: "Chains lightning.", upgrades: { path1: [{ name: "High Voltage", cost: 250, desc: "+Damage" }, { name: "Capacitor", cost: 550, desc: "More Chains" }, { name: "Overload", cost: 1400, desc: "Fast Fire Rate" }, { name: "Arc Reactor", cost: 3000, desc: "Chains Unlimited" }, { name: "Thunder God", cost: 7000, desc: "Screen Wipe Zap" }], path2: [{ name: "Static", cost: 300, desc: "Slows targets" }, { name: "Shock", cost: 600, desc: "Stuns targets" }, { name: "Chain Reaction", cost: 1500, desc: "Explodes on death" }, { name: "Storm Caller", cost: 3200, desc: "Strikes randoms" }, { name: "Zeus's Wrath", cost: 7500, desc: "Massive AoE Stun" }] } },
    fabricator: { name: "Fabricator", cost: 550, range: 100, damage: 40, cooldown: 100, color: "#808080", shape: "square", projectileSpeed: 0, type: "physical", desc: "Places mines on track.", upgrades: { path1: [{ name: "Proximity", cost: 300, desc: "Wider Trigger" }, { name: "Cluster Mine", cost: 600, desc: "Spawns 3 mines" }, { name: "High Explosive", cost: 1500, desc: "Huge Damage" }, { name: "Smart Mines", cost: 3500, desc: "Seek enemies" }, { name: "Nuke Layer", cost: 8000, desc: "Nuclear Mines" }], path2: [{ name: "Rune Trap", cost: 350, desc: "Magic Dmg" }, { name: "Frost Glyph", cost: 700, desc: "Freezes enemies" }, { name: "Gravity Sigil", cost: 1600, desc: "Sucks enemies in" }, { name: "Void Gate", cost: 3800, desc: "Teleports enemy back" }, { name: "Dimensional Rift", cost: 8500, desc: "Removes enemy" }] } },
    pylon: { name: "Chrono-Pylon", cost: 350, range: 100, damage: 0, cooldown: 0, color: "#ffffff", shape: "circle", type: "none", desc: "Buffs towers.", upgrades: { path1: [{ name: "Network Hub", cost: 200, desc: "+Range" }, { name: "Signal Boost", cost: 400, desc: "Stronger Buff" }, { name: "Global Uplink", cost: 1500, desc: "Global Buff" }, { name: "Overclock", cost: 3000, desc: "+Dmg Buff" }, { name: "Command Center", cost: 6000, desc: "Double Buff" }], path2: [{ name: "Time Field", cost: 250, desc: "Slow aura" }, { name: "Stasis Trap", cost: 500, desc: "Stuns" }, { name: "Temporal Rift", cost: 1200, desc: "Massive Slow" }, { name: "Time Warp", cost: 2800, desc: "Reverses enemies" }, { name: "Chronosphere", cost: 6500, desc: "Freezes Time" }] } },
    prism: { name: "Aether Prism", cost: 400, range: 180, damage: 1, cooldown: 0, color: "#bd00ff", shape: "triangle", type: "energy", desc: "Continuous beam.", upgrades: { path1: [{ name: "Focused Lens", cost: 250, desc: "x2 Damage" }, { name: "Gamma Burst", cost: 600, desc: "Armor Strip" }, { name: "Orbital Cannon", cost: 1500, desc: "Global Range" }, { name: "Plasma Cutter", cost: 3500, desc: "Melts HP" }, { name: "Death Star", cost: 8000, desc: "Obliterate" }], path2: [{ name: "Frost Runes", cost: 300, desc: "Slows" }, { name: "Entropy Field", cost: 650, desc: "Chains 2" }, { name: "Time Dilation", cost: 1400, desc: "Stops movement" }, { name: "Soul Drain", cost: 3000, desc: "Heals Lives" }, { name: "Void Ray", cost: 7500, desc: "Erases enemies" }] } },
    lance: { name: "Void Lance", cost: 500, range: 300, damage: 50, cooldown: 90, color: "#551A8B", shape: "triangle", projectileSpeed: 15, type: "physical", desc: "Sniper.", upgrades: { path1: [{ name: "Targeting", cost: 250, desc: "+Range/Speed" }, { name: "Thermal", cost: 600, desc: "Explosive" }, { name: "Anti-Matter", cost: 1500, desc: "Insta-kill" }, { name: "Rail-Gun", cost: 3500, desc: "Pierce All" }, { name: "Orbital Strike", cost: 9000, desc: "Nuke Map" }], path2: [{ name: "Shadow Bind", cost: 300, desc: "Roots" }, { name: "Soul Siphon", cost: 700, desc: "Gain Life" }, { name: "Abyssal Gaze", cost: 2000, desc: "% HP Dmg" }, { name: "Executioner", cost: 4000, desc: "Kill <50% HP" }, { name: "Reaper", cost: 9500, desc: "Boss Slayer" }] } },
    mortar: { name: "Gravity Mortar", cost: 600, range: 250, damage: 30, cooldown: 120, color: "#ffaa00", shape: "circle", projectileSpeed: 4, type: "physical", desc: "Splash damage.", upgrades: { path1: [{ name: "Dark Matter", cost: 350, desc: "+Radius" }, { name: "Singularity", cost: 800, desc: "Pulls enemies" }, { name: "Anti-Matter", cost: 2000, desc: "Massive Dmg" }, { name: "Napalm", cost: 4500, desc: "Fire Area" }, { name: "Nuclear Winter", cost: 9000, desc: "Rad Zone" }], path2: [{ name: "Acid", cost: 300, desc: "Acid Pool" }, { name: "Midas Touch", cost: 750, desc: "+Gold" }, { name: "Meteor Swarm", cost: 1800, desc: "Rain Fire" }, { name: "Plague", cost: 4000, desc: "Spreading DoT" }, { name: "Armageddon", cost: 9500, desc: "Screen Nuke" }] } },
    nullifier: { name: "Nullifier", cost: 700, range: 150, damage: 5, cooldown: 60, color: "#fff", shape: "orb", projectileSpeed: 10, type: "hybrid", desc: "Strips immunities.", upgrades: { path1: [{name:"Nanites", cost:300, desc:"AoE Cloud"}, {name:"Shredder", cost:600, desc:"Resist Strip"}, {name:"True Dmg", cost:1500, desc:"Ignore Armor"}, {name:"Destabilizer", cost:4000, desc:"Explode on Death"}, {name:"Grey Goo", cost:9000, desc:"Map Eater"}], path2: [{name:"Weakness", cost:300, desc:"+Damage Taken"}, {name:"Soul Sap", cost:600, desc:"Heal on hit"}, {name:"Doom", cost:1500, desc:"Dmg after time"}, {name:"Silence", cost:3500, desc:"Stop Abilities"}, {name:"Void Collapse", cost:9500, desc:"Black Hole"}]} }
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let gameState = {
    money: 300, lives: 100, wave: 1, isPlaying: false, gameOver: false, frames: 0, gameSpeed: 1, autoStart: false,
    mapIndex: 0, freezeTimer: 0,
    endless: false, 
    abilities: { laser: { cd: 0, maxCd: 1800 }, freeze: { cd: 0, maxCd: 3600 } },
    activeAbility: null,
    unlockedMaps: parseInt(localStorage.getItem('tad_unlocked')) || 1
};

let towers = [];
let enemies = [];
let projectiles = [];
let particles = [];
let mines = [];
let visualEffects = []; 
let buildMode = null; 
let selectedTower = null; 
let mousePos = { x: 0, y: 0 }; 
let pathPoints = []; 

// --- Input Handling & Resizing ---
// Update mouse pos based on canvas scaling
function updateMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    mousePos.x = (e.clientX - rect.left) * scaleX;
    mousePos.y = (e.clientY - rect.top) * scaleY;
}

canvas.addEventListener('mousemove', updateMousePos);

// --- Hotkeys ---
document.addEventListener('keydown', (e) => {
    if (gameState.gameOver || pathPoints.length === 0) return;
    
    const keyMap = {
        '1': 'miner', '2': 'sentry', '3': 'vent', '4': 'pylon', '5': 'prism',
        '6': 'coil', '7': 'lance', '8': 'fabricator', '9': 'mortar', '0': 'nullifier'
    };
    
    if (keyMap[e.key]) {
        selectTowerToBuild(keyMap[e.key]);
    }
    
    if (e.code === 'Space' && !gameState.isPlaying && !gameState.activeAbility && !buildMode) {
        startNextWave();
    }
});

class VisualEffect {
    constructor(type, x, y, options) {
        this.type = type; this.x = x; this.y = y;
        this.life = options.life || 20; this.maxLife = this.life;
        this.color = options.color || '#fff';
        this.targetX = options.targetX || x; this.targetY = options.targetY || y;
        this.radius = options.radius || 10;
        this.width = options.width || 2; this.angle = options.angle || 0;
        this.points = options.points || []; 
    }
    update() { this.life--; }
    draw(ctx) {
        ctx.save();
        const alpha = Math.max(0, this.life / this.maxLife);
        ctx.globalAlpha = alpha;
        
        if (this.type === 'lightning') {
            ctx.strokeStyle = this.color; ctx.lineWidth = this.width; ctx.shadowBlur = 10; ctx.shadowColor = this.color;
            ctx.beginPath();
            if (this.points.length > 0) { ctx.moveTo(this.points[0].x, this.points[0].y); for (let i = 1; i < this.points.length; i++) ctx.lineTo(this.points[i].x, this.points[i].y); }
            else { ctx.moveTo(this.x, this.y); ctx.lineTo(this.targetX, this.targetY); }
            ctx.stroke(); ctx.shadowBlur = 0;
        } 
        else if (this.type === 'cone') {
            ctx.translate(this.x, this.y); ctx.rotate(this.angle);
            const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
            grad.addColorStop(0, this.color); grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad; ctx.beginPath(); ctx.moveTo(0, 0); ctx.arc(0, 0, this.radius, -Math.PI/6, Math.PI/6); ctx.closePath(); ctx.fill();
        }
        else if (this.type === 'explosion') {
            const r = this.radius * (1 - alpha) * 2; 
            ctx.strokeStyle = this.color; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI*2); ctx.stroke();
            ctx.globalAlpha = alpha * 0.5; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, r * 0.8, 0, Math.PI*2); ctx.fill();
        }
        else if (this.type === 'laser_orbit') {
            ctx.fillStyle = '#fff'; ctx.fillRect(this.x-5, 0, 10, this.y);
            ctx.fillStyle = 'rgba(0, 243, 255, 0.5)'; ctx.beginPath(); ctx.arc(this.x, this.y, 60, 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color, size, life) {
        this.x = x; this.y = y; this.color = color; this.size = size; this.life = life; this.maxLife = life;
        const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 3 + 1;
        this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
    }
    update() { this.x += this.vx; this.y += this.vy; this.vx *= 0.95; this.vy *= 0.95; this.life--; }
    draw(ctx) { ctx.globalAlpha = this.life / this.maxLife; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; }
}

class Enemy {
    constructor(typeKey) {
        let type = ENEMIES[typeKey];
        if (!type) { console.warn("Invalid enemy type detected: " + typeKey + ". Defaulting to 'basic'."); type = ENEMIES['basic']; }
        let diffMod = MAPS[gameState.mapIndex].difficultyMod;
        if (gameState.wave > 20) { diffMod += (gameState.wave - 20) * 0.1 * diffMod; }
        this.hp = Math.floor(type.hp * diffMod); this.maxHp = this.hp; this.speed = type.speed;
        this.color = type.color; this.reward = type.reward; this.radius = type.radius;
        this.name = type.name; this.shape = type.shape; this.resistance = type.resistance; this.fly = type.fly || false;
        
        if (this.fly) {
            this.start = pathPoints[0]; this.end = pathPoints[pathPoints.length-1];
            this.x = this.start.x; this.y = this.start.y; this.totalDist = Math.hypot(this.end.x - this.start.x, this.end.y - this.start.y); this.currentDist = 0;
        } else {
            this.pathIndex = 0; this.x = pathPoints[0].x; this.y = pathPoints[0].y;
        }
        this.distanceTravelled = 0; this.slowTimer = 0; this.stunTimer = 0; this.dotTimer = 0; this.regenTimer = 0;
    }
    update() {
        if (gameState.freezeTimer > 0) return; 
        let currentSpeed = this.speed;
        if (this.stunTimer > 0) { currentSpeed = 0; this.stunTimer--; }
        else if (this.slowTimer > 0) { currentSpeed = this.speed * 0.5; this.slowTimer--; }
        if (this.dotTimer > 0) { if (this.dotTimer % 60 === 0) this.takeDamage(5); this.dotTimer--; }
        if (this.name === "Regenerator") { this.regenTimer++; if (this.regenTimer > 60) { if (this.hp < this.maxHp) this.hp += 10; this.regenTimer = 0; } }
        if (this.name === "Phase-Shifter" && Math.random() < 0.005) { this.x += (Math.random() - 0.5) * 40; this.y += (Math.random() - 0.5) * 40; particles.push(new Particle(this.x, this.y, this.color, 4, 15)); }
        if (currentSpeed <= 0) return;

        if (this.fly) {
            this.currentDist += currentSpeed;
            let progress = this.currentDist / this.totalDist;
            if (progress >= 1) { this.reachEnd(); return; }
            this.x = this.start.x + (this.end.x - this.start.x) * progress;
            this.y = this.start.y + (this.end.y - this.start.y) * progress;
            this.distanceTravelled = this.currentDist;
        } else {
            const target = pathPoints[this.pathIndex + 1]; if (!target) return;
            const dx = target.x - this.x; const dy = target.y - this.y; const dist = Math.hypot(dx, dy);
            if (dist <= currentSpeed) { this.x = target.x; this.y = target.y; this.pathIndex++; if (this.pathIndex >= pathPoints.length - 1) this.reachEnd(); }
            else { this.x += (dx / dist) * currentSpeed; this.y += (dy / dist) * currentSpeed; }
            this.distanceTravelled += currentSpeed;
        }
    }
    takeDamage(amount, sourceTower) {
        let actualDamage = amount;
        if (sourceTower && sourceTower.type !== 'none' && sourceTower.type !== 'hybrid') {
            if (this.resistance === 'all') actualDamage *= 0.8;
            if (this.resistance === 'physical' && sourceTower.type === 'physical') { actualDamage *= 0.25; particles.push(new Particle(this.x, this.y, '#888', 2, 10)); }
            if (this.resistance === 'energy' && sourceTower.type === 'energy') { actualDamage *= 0.25; particles.push(new Particle(this.x, this.y, '#000', 2, 10)); }
        }
        if (sourceTower) sourceTower.totalDamage += actualDamage; 
        this.hp -= actualDamage;
        if (Math.random() < 0.3) particles.push(new Particle(this.x, this.y, this.color, 2, 10));
        if (this.hp <= 0) this.die(sourceTower);
    }
    die(sourceTower) {
        let reward = this.reward;
        if (sourceTower && sourceTower.type === 'mortar' && sourceTower.path === 2 && sourceTower.level >= 2) reward = Math.floor(reward * 1.5);
        if (sourceTower && sourceTower.type === 'miner' && sourceTower.path === 2 && sourceTower.level >= 5) reward += 5;
        towers.forEach(t => { if(t.type === 'miner' && t.path === 2 && t.level >= 1) { if (Math.hypot(t.x - this.x, t.y - this.y) < 150) reward += 1; } });
        if (sourceTower && sourceTower.type === 'lance' && sourceTower.path === 2 && sourceTower.level >= 2) { if (Math.random() < 0.1) gameState.lives++; }
        if (sourceTower && sourceTower.type === 'prism' && sourceTower.path === 2 && sourceTower.level >= 4) { if (Math.random() < 0.05) gameState.lives++; }
        gameState.money += reward;
        for(let i=0; i<5; i++) particles.push(new Particle(this.x, this.y, this.color, 4, 30)); 
        const idx = enemies.indexOf(this); if (idx > -1) enemies.splice(idx, 1);
        Sound.play('explosion');
    }
    reachEnd() {
        gameState.lives--; const idx = enemies.indexOf(this); if (idx > -1) enemies.splice(idx, 1);
        if (gameState.lives <= 0 && !gameState.gameOver) endGame();
    }
    draw() {
        ctx.save(); ctx.translate(this.x, this.y); ctx.fillStyle = this.color; ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
        ctx.beginPath();
        if (this.shape === 'circle') { ctx.arc(0, 0, this.radius, 0, Math.PI * 2); }
        else if (this.shape === 'square') { ctx.fillRect(-this.radius, -this.radius, this.radius*2, this.radius*2); ctx.rect(-this.radius, -this.radius, this.radius*2, this.radius*2); }
        else if (this.shape === 'triangle' || this.shape === 'triangle_small') { ctx.moveTo(0, -this.radius); ctx.lineTo(this.radius, this.radius); ctx.lineTo(-this.radius, this.radius); ctx.closePath(); }
        else if (this.shape === 'pentagon') { for (let i = 0; i < 5; i++) { ctx.lineTo(this.radius * Math.cos(i * 2 * Math.PI / 5 - Math.PI/2), this.radius * Math.sin(i * 2 * Math.PI / 5 - Math.PI/2)); } ctx.closePath(); }
        else if (this.shape === 'diamond') { ctx.moveTo(0, -this.radius * 1.5); ctx.lineTo(this.radius, 0); ctx.lineTo(0, this.radius * 1.5); ctx.lineTo(-this.radius, 0); ctx.closePath(); }
        else if (this.shape === 'star_6' || this.shape === 'star_4') { const points = this.shape === 'star_6' ? 6 : 4; for(let i=0; i<points*2; i++){ const r = (i%2 === 0) ? this.radius : this.radius/2; const a = (Math.PI * i) / points; ctx.lineTo(r * Math.cos(a), r * Math.sin(a)); } ctx.closePath(); }
        else if (this.shape === 'skull' || this.shape === 'omega') { ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.moveTo(-5, -5); ctx.lineTo(5, 5); ctx.moveTo(5, -5); ctx.lineTo(-5, 5); }
        else if (this.shape === 'arrow') { ctx.moveTo(this.radius, 0); ctx.lineTo(-this.radius, -this.radius/2); ctx.lineTo(-this.radius, this.radius/2); ctx.closePath(); }
        else if (this.shape === 'cross') { ctx.fillRect(-this.radius, -this.radius/3, this.radius*2, this.radius/1.5); ctx.fillRect(-this.radius/3, -this.radius, this.radius/1.5, this.radius*2); }
        else if (this.shape === 'diamond_solid') { ctx.rotate(Math.PI/4); ctx.fillRect(-this.radius, -this.radius, this.radius*2, this.radius*2); }
        else if (this.shape === 'star_dark') { for(let i=0; i<8; i++){ const r = (i%2 === 0) ? this.radius : this.radius/3; const a = (Math.PI * i) / 4; ctx.lineTo(r * Math.cos(a), r * Math.sin(a)); } ctx.closePath(); }
        else if (this.shape === 'wing') { ctx.moveTo(0,0); ctx.lineTo(-10, -5); ctx.lineTo(-5, 0); ctx.lineTo(-10, 5); ctx.fill(); } 
        
        ctx.fill(); ctx.stroke(); ctx.restore();
        const hpPercent = Math.max(0, this.hp / this.maxHp);
        ctx.fillStyle = '#ff0000'; ctx.fillRect(this.x - 10, this.y - this.radius - 8, 20, 4);
        ctx.fillStyle = '#00ff00'; ctx.fillRect(this.x - 10, this.y - this.radius - 8, 20 * hpPercent, 4);
    }
}

class Tower {
    constructor(x, y, typeKey) {
        const type = TOWER_TYPES[typeKey];
        this.x = x; this.y = y; this.type = typeKey; this.name = type.name;
        this.range = type.range; this.damage = type.damage; this.cooldownMax = type.cooldown;
        this.cooldown = 0; this.color = type.color; this.shape = type.shape;
        this.projectileSpeed = type.projectileSpeed || 0;
        this.path = 0; this.level = 0; this.angle = 0; this.buffSpeedMultiplier = 1.0;
        this.buffDamageMultiplier = 1.0; this.buffRangeMultiplier = 1.0; this.buffCostMultiplier = 1.0;
        this.priority = 'first'; 
        this.currentTarget = null;
        this.totalDamage = 0; 
    }
    update() { 
        this.buffSpeedMultiplier = 1.0; 
        this.buffDamageMultiplier = 1.0;
        this.buffRangeMultiplier = 1.0;
        this.buffCostMultiplier = 1.0;
        if (this.cooldown > 0) this.cooldown--; 
    }
    
    getTarget(candidates) {
        if (candidates.length === 0) return null;
        return candidates.sort((a, b) => {
            if (this.priority === 'first') return b.distanceTravelled - a.distanceTravelled;
            if (this.priority === 'last') return a.distanceTravelled - b.distanceTravelled;
            if (this.priority === 'closest') return Math.hypot(a.x - this.x, a.y - this.y) - Math.hypot(b.x - this.x, b.y - this.y);
            if (this.priority === 'farthest') return Math.hypot(b.x - this.x, b.y - this.y) - Math.hypot(a.x - this.x, a.y - this.y);
            if (this.priority === 'strongest') return b.hp - a.hp;
            if (this.priority === 'flying') {
                if (a.fly !== b.fly) return b.fly ? 1 : -1;
                return b.distanceTravelled - a.distanceTravelled;
            }
            return b.distanceTravelled - a.distanceTravelled;
        })[0];
    }

    act() {
        if (gameState.freezeTimer > 0) return; 

        let cd = this.cooldownMax / this.buffSpeedMultiplier;
        this.currentTarget = null;

        if (this.type === 'pylon') {
            let buffRange = this.range;
            if (this.path === 1 && this.level >= 1) buffRange += 50; if (this.path === 1 && this.level >= 3) buffRange = 2000;
            
            // Apply buffs to neighbors
            towers.forEach(t => { 
                if (t === this) return; 
                if (Math.hypot(t.x - this.x, t.y - this.y) <= buffRange) { 
                    // Base: +20% Damage
                    t.buffDamageMultiplier = Math.max(t.buffDamageMultiplier, 1.2);
                    
                    // Path 1 Lvl 2: +20% Range
                    if (this.path === 1 && this.level >= 2) t.buffRangeMultiplier = Math.max(t.buffRangeMultiplier, 1.2);
                    
                    // Path 1 Lvl 4: 10% Discount
                    if (this.path === 1 && this.level >= 4) t.buffCostMultiplier = Math.min(t.buffCostMultiplier, 0.9);
                    
                    // Path 1 Lvl 5: 25% Discount and +50% Damage
                    if (this.path === 1 && this.level >= 5) {
                        t.buffCostMultiplier = Math.min(t.buffCostMultiplier, 0.75);
                        t.buffDamageMultiplier = Math.max(t.buffDamageMultiplier, 1.5);
                    }
                } 
            });
            if (this.path === 2) { enemies.forEach(e => { if (Math.hypot(e.x - this.x, e.y - this.y) <= this.range) { if (this.level >= 1) e.slowTimer = 5; if (this.level >= 5) e.stunTimer = 1; } }); }
            return; 
        }
        if (this.type === 'miner') return;
        
        let effectiveRange = this.range * this.buffRangeMultiplier;
        let effectiveDamage = this.damage * this.buffDamageMultiplier;

        if (this.type === 'fabricator') {
            if (this.cooldown <= 0) {
                 // Calculate spawn position on path
                 let validPoints = [];
                 for(let i=0; i<pathPoints.length-1; i++) {
                     // Check if segment is close
                     let p1 = pathPoints[i];
                     let p2 = pathPoints[i+1];
                     // Simplified: Check midpoints or sample points
                     // Just check distance to p1, p2 for simplicity in this tick
                     if (Math.hypot(p1.x - this.x, p1.y - this.y) < effectiveRange) validPoints.push(p1);
                     if (Math.hypot(p2.x - this.x, p2.y - this.y) < effectiveRange) validPoints.push(p2);
                 }
                 
                 if(validPoints.length > 0) {
                     let p = validPoints[Math.floor(Math.random()*validPoints.length)];
                     mines.push({ x: p.x + (Math.random()-0.5)*10, y: p.y + (Math.random()-0.5)*10, damage: effectiveDamage * (1 + this.level), radius: 20, life: 600, type: (this.path===2)?'rune':'tech', source: this });
                     this.cooldown = cd;
                 }
            }
            return;
        }
        if (this.type === 'vent') {
            let target = null; let minD = Infinity;
            enemies.forEach(e => { let d = Math.hypot(e.x - this.x, e.y - this.y); if (d <= effectiveRange && d < minD) { minD = d; target = e; } });
            if (target) {
                this.angle = Math.atan2(target.y - this.y, target.x - this.x);
                if (this.cooldown <= 0) {
                    enemies.forEach(e => {
                        let d = Math.hypot(e.x - this.x, e.y - this.y);
                        if (d <= effectiveRange) {
                            let angleToEnemy = Math.atan2(e.y - this.y, e.x - this.x);
                            let diff = angleToEnemy - this.angle;
                            while (diff < -Math.PI) diff += Math.PI * 2; while (diff > Math.PI) diff -= Math.PI * 2;
                            if (Math.abs(diff) < 0.5) {
                                e.takeDamage(effectiveDamage + (this.level * 2), this);
                                if(this.path === 2 && this.level >= 1) e.slowTimer = 10;
                                if(this.path === 1 && this.level >= 3) e.takeDamage(1, this);
                            }
                        }
                    });
                    visualEffects.push(new VisualEffect('cone', this.x, this.y, { angle: this.angle, radius: effectiveRange, color: this.path === 2 ? '#8A2BE2' : '#FF4500', life: 7 }));
                    Sound.play(this.path===2?'shoot_magic':'shoot_tech');
                    this.cooldown = 6; 
                }
            }
            return;
        }
        
        let validTargets = [];
        if (this.type === 'lance' && this.path === 1 && this.level >= 1) effectiveRange += 100;
        if (this.type === 'prism' && this.path === 1 && this.level >= 3) effectiveRange = 2000;

        for (const enemy of enemies) {
            let dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
            if (dist <= effectiveRange) validTargets.push(enemy);
        }

        let target = this.getTarget(validTargets);

        if (target) {
            this.angle = Math.atan2(target.y - this.y, target.x - this.x);
            this.currentTarget = target; 
            if (this.cooldown <= 0) { this.shoot(target, effectiveDamage); this.cooldown = cd; }
        }
    }
    shoot(target, dmg) {
        Sound.play((this.type==='prism' || this.path===2) ? 'shoot_magic' : 'shoot_tech');
        if (this.type === 'prism') {
            let d = dmg * (1 + this.level);
            if (this.path === 1 && this.level >= 1) d *= 2; if (this.path === 1 && this.level >= 5) d *= 5; 
            target.takeDamage(d, this);
            if (this.path === 2 && this.level >= 1) target.slowTimer = 5; 
            if (this.path === 2 && this.level >= 5) target.hp = 0; 
            if (this.path === 2 && this.level >= 2) this.chainLightning(target, 2, d); 
            return;
        }
        if (this.type === 'coil') {
            this.chainLightning(target, 2 + this.level, dmg); 
            let pts = [{x:this.x, y:this.y}];
            let steps = 5;
            for(let i=1; i<steps; i++){
                let t = i/steps;
                pts.push({ x: this.x + (target.x - this.x)*t + (Math.random()-0.5)*20, y: this.y + (target.y - this.y)*t + (Math.random()-0.5)*20 });
            }
            pts.push({x:target.x, y:target.y});
            visualEffects.push(new VisualEffect('lightning', this.x, this.y, { points: pts, color: '#00FFFF', life: 5, width: 2 }));
            return;
        }
        if (this.type === 'nullifier') {
            let p = new Projectile(this.x, this.y, target, this.type, dmg + (this.level*5), this.projectileSpeed, this);
            if (this.path === 1 && this.level >= 1) p.explosionRadius = 40; 
            projectiles.push(p);
            return;
        }

        let p = new Projectile(this.x, this.y, target, this.type, dmg, this.projectileSpeed, this);
        if (this.type === 'sentry') {
            if (this.path === 1 && this.level >= 2) p.pierce = 1;
            if (this.path === 1 && this.level >= 5) p.damage *= 10; 
            if (this.path === 2 && this.level >= 2) p.seeking = true;
            if (this.path === 2 && this.level >= 3) { setTimeout(() => projectiles.push(new Projectile(this.x, this.y, target, this.type, dmg, this.projectileSpeed, this)), 5); setTimeout(() => projectiles.push(new Projectile(this.x, this.y, target, this.type, dmg, this.projectileSpeed, this)), 10); }
        }
        if (this.type === 'mortar') {
             if (this.path === 1 && this.level >= 1) p.explosionRadius *= 1.5;
             if (this.path === 1 && this.level >= 3) p.damage *= 5; 
             if (this.path === 2 && this.level >= 5) p.explosionRadius = 1000; 
        }
        if (this.type === 'lance') {
            if (this.path === 1 && this.level >= 2) p.isExplosive = true;
            if (this.path === 1 && this.level >= 5) p.damage = 9999; 
        }
        projectiles.push(p);
    }
    onWaveEnd() {
        if (this.type === 'miner') {
            let gain = 15; gain += this.level * 10; 
            if (this.path === 1 && this.level >= 1) gain += 10; if (this.path === 1 && this.level >= 4) gain += 150;
            if (this.path === 2 && this.level >= 2) gain += 40; if (this.path === 2 && this.level >= 3) gain += 100; if (this.path === 2 && this.level >= 4) gain *= 2; 
            if (this.path === 1 && this.level >= 3) gain += Math.floor(gameState.money * 0.1);
            if (this.path === 1 && this.level >= 5) gain += Math.floor(gameState.money * 0.2); 
            gameState.money += gain;
            particles.push(new Particle(this.x, this.y, '#ffd700', 5, 40));
        }
    }
    chainLightning(target, bounces, dmg) {
        if (bounces <= 0) return;
        let nextTarget = null; let minD = 200; 
        for (const e of enemies) {
            if (e === target) continue;
            const d = Math.hypot(e.x - target.x, e.y - target.y);
            if (d < minD) { minD = d; nextTarget = e; }
        }
        if (nextTarget) {
            let pts = [{x:target.x, y:target.y}];
            let steps = 5;
            for(let i=1; i<steps; i++){
                let t = i/steps;
                pts.push({
                    x: target.x + (nextTarget.x - target.x)*t + (Math.random()-0.5)*20,
                    y: target.y + (nextTarget.y - target.y)*t + (Math.random()-0.5)*20
                });
            }
            pts.push({x:nextTarget.x, y:nextTarget.y});
            visualEffects.push(new VisualEffect('lightning', 0, 0, {
                points: pts, color: '#00FFFF', life: 5, width: 1.5
            }));
            nextTarget.takeDamage(dmg, this);
            if (this.path === 2 && this.level >= 2) nextTarget.stunTimer = 10;
            this.chainLightning(nextTarget, bounces - 1, dmg);
        }
    }
    
    // Updated Draw Function with VISUALS
    draw() {
        ctx.save(); ctx.translate(this.x, this.y);
        
        // Only show range if selected
        if (this === selectedTower) {
            let r = this.range * this.buffRangeMultiplier; // Visualize Buffed Range
            if (this.type === 'pylon' && this.path === 1 && this.level >= 1) r += 50;
            if (this.type === 'pylon' && this.path === 1 && this.level >= 3) r = 1000;
            ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fillStyle = C_RANGE; ctx.fill(); ctx.strokeStyle = C_RANGE_BORDER; ctx.stroke();
        }

        // Draw Sparkle if Buffed
        if (this.buffDamageMultiplier > 1.0) {
             ctx.save();
             ctx.fillStyle = "#FFD700"; // Gold sparkle
             ctx.globalAlpha = 0.6 + Math.sin(gameState.frames * 0.2) * 0.4;
             ctx.beginPath(); ctx.arc(0, -25, 4, 0, Math.PI*2); ctx.fill();
             ctx.restore();
        }
        
        // Base Rotation
        if (!['pylon','miner','fabricator','nullifier','vent'].includes(this.type)) ctx.rotate(this.angle);
        else if (this.type === 'vent') ctx.rotate(this.angle);

        // Pedestal
        ctx.fillStyle = "#111";
        ctx.shadowBlur = 0;
        if (this.path === 2) { 
             ctx.beginPath();
             for(let i=0; i<6; i++) { ctx.lineTo(16 * Math.cos(i * Math.PI / 3), 16 * Math.sin(i * Math.PI / 3)); }
             ctx.closePath(); ctx.fill(); ctx.strokeStyle = "#444"; ctx.lineWidth = 1; ctx.stroke();
        } else { 
            ctx.fillRect(-14, -14, 28, 28); ctx.strokeStyle = "#444"; ctx.lineWidth = 1; ctx.strokeRect(-14, -14, 28, 28);
        }

        // Body
        let grad = ctx.createLinearGradient(-10, -10, 10, 10);
        grad.addColorStop(0, this.color); grad.addColorStop(1, '#1a1a1a'); 
        ctx.fillStyle = grad;

        if (this.shape === 'square') { ctx.fillRect(-10, -10, 20, 20); ctx.fillStyle = "#000"; ctx.fillRect(-4, -4, 8, 8); }
        else if (this.shape === 'triangle') { ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(-10, 10); ctx.lineTo(-10, -10); ctx.fill(); ctx.beginPath(); ctx.moveTo(5, 0); ctx.lineTo(-5, 5); ctx.lineTo(-5, -5); ctx.fillStyle = "#000"; ctx.fill(); }
        else if (this.shape === 'circle') { ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI * 2); ctx.fillStyle = "#000"; ctx.fill(); }
        else if (this.shape === 'orb') { 
            ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.fill();
            ctx.globalAlpha = 0.5; ctx.beginPath(); ctx.arc(0, 0, 12 + Math.sin(gameState.frames*0.1)*2, 0, Math.PI * 2); ctx.stroke(); ctx.globalAlpha = 1.0;
        }

        // Overlay Textures
        ctx.shadowBlur = 8; ctx.lineWidth = 2;
        
        if (this.path === 1) { // TECH
            ctx.strokeStyle = "#00f3ff"; ctx.shadowColor = "#00f3ff"; ctx.beginPath();
            if (this.level >= 1) { ctx.moveTo(-10, -10); ctx.lineTo(-5, -5); ctx.moveTo(10, 10); ctx.lineTo(5, 5); ctx.moveTo(10, -10); ctx.lineTo(5, -5); ctx.moveTo(-10, 10); ctx.lineTo(-5, 5); }
            if (this.level >= 2) { ctx.rect(-5, -5, 10, 10); }
            if (this.level >= 3) { ctx.moveTo(0, -10); ctx.lineTo(0, -5); ctx.moveTo(0, 10); ctx.lineTo(0, 5); ctx.moveTo(-10, 0); ctx.lineTo(-5, 0); ctx.moveTo(10, 0); ctx.lineTo(5, 0); }
            if (this.level >= 4) { ctx.moveTo(-8, -8); ctx.lineTo(8, -8); ctx.moveTo(8, -8); ctx.lineTo(8, 8); ctx.moveTo(8, 8); ctx.lineTo(-8, 8); ctx.moveTo(-8, 8); ctx.lineTo(-8, -8); ctx.fillRect(-12,-12,4,4); ctx.fillRect(8,-12,4,4); ctx.fillRect(8,8,4,4); ctx.fillRect(-12,8,4,4); }
            if (this.level >= 5) { ctx.shadowBlur = 15; ctx.arc(0,0, 16, 0, Math.PI*2); }
            ctx.stroke(); ctx.shadowBlur = 0; 
        } 
        else if (this.path === 2) { // MAGIC
            ctx.strokeStyle = "#bd00ff"; ctx.shadowColor = "#bd00ff"; ctx.beginPath();
            if (this.level >= 1) { ctx.arc(0, 0, 4, 0, Math.PI*2); } 
            if (this.level >= 2) { ctx.moveTo(0, -8); ctx.lineTo(7, 4); ctx.lineTo(-7, 4); ctx.closePath(); }
            if (this.level >= 3) { ctx.moveTo(10, 0); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.moveTo(0, -12); ctx.lineTo(0, -8); ctx.moveTo(0, 12); ctx.lineTo(0, 8); ctx.moveTo(-12, 0); ctx.lineTo(-8, 0); ctx.moveTo(12, 0); ctx.lineTo(8, 0); }
            if (this.level >= 4) { ctx.rect(-6, -6, 12, 12); ctx.moveTo(-6, -6); ctx.lineTo(6, 6); ctx.moveTo(6, -6); ctx.lineTo(-6, 6); }
            if (this.level >= 5) { ctx.shadowBlur = 15; for(let i=0; i<5; i++){ ctx.moveTo(15 * Math.cos(i * 4 * Math.PI / 5 - Math.PI/2), 15 * Math.sin(i * 4 * Math.PI / 5 - Math.PI/2)); ctx.lineTo(15 * Math.cos((i+2) * 4 * Math.PI / 5 - Math.PI/2), 15 * Math.sin((i+2) * 4 * Math.PI / 5 - Math.PI/2)); } }
            ctx.stroke(); ctx.shadowBlur = 0;
        }

        ctx.fillStyle = "#fff";
        for(let i=0; i<this.level; i++) { ctx.beginPath(); ctx.arc(-12 + (i*6), -22, 2, 0, Math.PI*2); ctx.fill(); }
        
        if (this.type === 'prism' && this.currentTarget && enemies.includes(this.currentTarget)) {
            ctx.restore(); ctx.save();
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.currentTarget.x, this.currentTarget.y);
            ctx.strokeStyle = this.color; ctx.lineWidth = 2 + this.level; ctx.shadowColor = this.color; ctx.shadowBlur = 10; ctx.stroke(); ctx.shadowBlur = 0;
            return; 
        }
        ctx.restore();
    }
}

class Projectile {
    constructor(x, y, target, type, damage, speed, sourceTower) {
        this.x = x; this.y = y; this.target = target;
        this.targetX = target.x; this.targetY = target.y;
        this.type = type; this.damage = damage; this.speed = speed;
        this.sourceTower = sourceTower;
        this.active = true; this.pierce = 0; this.seeking = false;
        this.explosionRadius = 0; this.isExplosive = false;
        if (type === 'mortar' || (type === 'nullifier' && sourceTower.path === 1 && sourceTower.level >= 1)) { 
            this.explosionRadius = 40; this.targetX = target.x; this.targetY = target.y; 
        }
    }
    update() {
        if (!this.active) return;
        let tx = this.targetX; let ty = this.targetY;
        if (this.type !== 'mortar' && this.type !== 'nullifier' && this.target && enemies.includes(this.target)) { tx = this.target.x; ty = this.target.y; }
        else if (this.seeking && this.target && enemies.includes(this.target)) { tx = this.target.x; ty = this.target.y; }
        const dx = tx - this.x; const dy = ty - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist <= this.speed) this.hit();
        else { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; }
    }
    hit() {
        this.active = false;
        if (this.type === 'mortar' || this.isExplosive || (this.type === 'nullifier' && this.explosionRadius > 0)) {
            let rad = this.explosionRadius || 30;
            Sound.play('explosion');
            visualEffects.push(new VisualEffect('explosion', this.x, this.y, { radius: rad, color: this.type==='nullifier'?'#fff':'#ffaa00', life: 15 }));
            if (this.type !== 'nullifier') for(let i=0; i<10; i++) particles.push(new Particle(this.x, this.y, '#ffaa00', 4, 25));
            
            enemies.forEach(e => {
                if (Math.hypot(e.x - this.x, e.y - this.y) <= rad) {
                    if (this.type === 'nullifier') {
                        e.resistance = 'none'; // Strip resistance
                        e.takeDamage(this.damage, this.sourceTower);
                        if (this.sourceTower.path === 2 && this.sourceTower.level >= 1) e.takeDamage(e.hp * 0.1, this.sourceTower); // Weakness logic simplfied
                    } else {
                        e.takeDamage(this.damage, this.sourceTower);
                    }
                }
            });
        } else {
            if (this.target && enemies.includes(this.target)) {
                if (this.type === 'nullifier') {
                    this.target.resistance = 'none';
                    this.target.takeDamage(this.damage, this.sourceTower);
                } else {
                    this.target.takeDamage(this.damage, this.sourceTower);
                }
                if (this.pierce > 0) { this.pierce--; this.active = true; }
            }
        }
    }
    draw() {
        ctx.beginPath();
        if (this.type === 'mortar') { ctx.fillStyle = "#ffaa00"; ctx.arc(this.x, this.y, 6, 0, Math.PI * 2); }
        else if (this.type === 'nullifier') { ctx.fillStyle = "#fff"; ctx.arc(this.x, this.y, 4, 0, Math.PI * 2); }
        else if (this.type === 'lance') { ctx.fillStyle = "#A020F0"; ctx.fillRect(this.x-2, this.y-2, 4, 4); }
        else { ctx.fillStyle = "#00f3ff"; ctx.arc(this.x, this.y, 3, 0, Math.PI * 2); }
        ctx.fill();
    }
}

// --- Global Functions ---

function toggleSpeed() {
    if (gameState.gameSpeed === 1) gameState.gameSpeed = 2;
    else if (gameState.gameSpeed === 2) gameState.gameSpeed = 4;
    else gameState.gameSpeed = 1;
    document.getElementById('speed-btn').innerText = gameState.gameSpeed + "x";
}

function toggleAutoStart() {
    gameState.autoStart = !gameState.autoStart;
    const btn = document.getElementById('auto-btn');
    btn.innerText = "Auto: " + (gameState.autoStart ? "ON" : "OFF");
    btn.classList.toggle('auto-on');
}

function selectTowerToBuild(type, el) {
    document.querySelectorAll('.tower-card').forEach(c => c.classList.remove('selected'));
    
    // Close shop on selection to unobstruct view
    if (document.getElementById('shop-dropdown')) {
        document.getElementById('shop-dropdown').classList.remove('open');
    }

    if (buildMode === type) { 
        buildMode = null; 
        canvas.style.cursor = 'default'; 
    } else { 
        buildMode = type; 
        // Logic to highlight the card if selected via hotkey
        if (!el) {
             // find the element
             const cardId = 'card-' + type;
             const card = document.getElementById(cardId);
             if (card) card.classList.add('selected');
        } else {
             el.classList.add('selected'); 
        }
        
        canvas.style.cursor = 'crosshair'; 
        selectedTower = null; 
        updateUpgradeMenu(); 
    }
    
    if (gameState.activeAbility) {
        gameState.activeAbility = null;
        canvas.style.cursor = 'default';
    }
}

function activateAbility(type) {
    if (gameState.abilities[type].cd > 0) return;
    
    if (type === 'laser') {
        gameState.activeAbility = 'laser';
        canvas.style.cursor = 'crosshair';
        buildMode = null; // Cancel building
        document.querySelectorAll('.tower-card').forEach(c => c.classList.remove('selected'));
    } else if (type === 'freeze') {
        // Instant Trigger
        gameState.freezeTimer = 300; // 5 seconds at 60fps
        gameState.abilities.freeze.cd = gameState.abilities.freeze.maxCd;
        Sound.play('freeze');
        visualEffects.push(new VisualEffect('explosion', CANVAS_WIDTH/2, CANVAS_HEIGHT/2, { radius: 1000, color: '#00ffff', life: 30 }));
    }
}

function useActiveAbility(x, y) {
    if (gameState.activeAbility === 'laser') {
        // Spawn massive damage area
        visualEffects.push(new VisualEffect('laser_orbit', x, y, { life: 30 }));
        Sound.play('explosion'); // Laser sound placeholder
        enemies.forEach(e => {
            if (Math.hypot(e.x - x, e.y - y) < 60) {
                e.takeDamage(500, null); // 500 Dmg
            }
        });
        gameState.abilities.laser.cd = gameState.abilities.laser.maxCd;
        gameState.activeAbility = null;
        canvas.style.cursor = 'default';
    }
}

function cyclePriority() {
    if (!selectedTower) return;
    const p = selectedTower.priority;
    if (p === 'first') selectedTower.priority = 'last';
    else if (p === 'last') selectedTower.priority = 'closest';
    else if (p === 'closest') selectedTower.priority = 'farthest';
    else if (p === 'farthest') selectedTower.priority = 'strongest';
    else if (p === 'strongest') selectedTower.priority = 'flying';
    else selectedTower.priority = 'first';
    const btn = document.getElementById('priority-btn');
    btn.innerText = "Target: " + selectedTower.priority.charAt(0).toUpperCase() + selectedTower.priority.slice(1);
}

function refreshShopAffordability() {
    for(const key in TOWER_TYPES) {
        const t = TOWER_TYPES[key];
        const card = document.getElementById('card-' + key);
        if (card) {
            if (gameState.money < t.cost) card.classList.add('too-expensive'); else card.classList.remove('too-expensive');
        }
    }
}

function updateUI() {
    document.getElementById('money-display').innerText = gameState.money;
    document.getElementById('lives-display').innerText = gameState.lives;
    const waveText = document.getElementById('wave-display');
    waveText.innerText = gameState.wave;
    if (gameState.endless) waveText.classList.add('endless');
    else waveText.classList.remove('endless');
    
    // Ability CDs
    const laserPct = Math.min(100, (gameState.abilities.laser.cd / gameState.abilities.laser.maxCd) * 100);
    document.getElementById('cd-laser').style.height = laserPct + "%";
    
    const freezePct = Math.min(100, (gameState.abilities.freeze.cd / gameState.abilities.freeze.maxCd) * 100);
    document.getElementById('cd-freeze').style.height = freezePct + "%";

    refreshShopAffordability();
}

function updateUpgradeMenu() {
    const menu = document.getElementById('upgrade-modal');
    if (!selectedTower) { menu.style.display = "none"; return; }
    
    menu.style.display = "flex";
    document.getElementById('selected-tower-name').innerText = selectedTower.name;
    document.getElementById('dps-display').innerText = "Total Dmg: " + Math.floor(selectedTower.totalDamage);
    const info = TOWER_TYPES[selectedTower.type];
    
    // Apply Discount if buffed
    let cost = info.cost * 0.7;
    document.getElementById('sell-value').innerText = Math.floor(cost);

    const btn = document.getElementById('priority-btn');
    if (['miner','pylon','fabricator','vent'].includes(selectedTower.type)) btn.style.display = 'none'; 
    else {
        btn.style.display = 'inline-block';
        btn.innerText = "Target: " + selectedTower.priority.charAt(0).toUpperCase() + selectedTower.priority.slice(1);
    }

    const nextLvl = selectedTower.level + 1;
    const p1Btn = document.getElementById('btn-upgrade-1');
    const p2Btn = document.getElementById('btn-upgrade-2');
    
    p1Btn.disabled = true; p2Btn.disabled = true;
    document.getElementById('path-1-desc').innerText = "Maxed"; document.getElementById('cost-1').innerText = "-";
    document.getElementById('path-2-desc').innerText = "Maxed"; document.getElementById('cost-2').innerText = "-";

    if (nextLvl > 5) return;

    // Apply Cost Multiplier from Pylon Buffs
    const discountMult = selectedTower.buffCostMultiplier || 1.0;

    if (selectedTower.path === 0 || selectedTower.path === 1) {
        const upg = info.upgrades.path1[selectedTower.level];
        const cost = Math.floor(upg.cost * discountMult);
        document.getElementById('path-1-desc').innerText = upg.name + ": " + upg.desc;
        document.getElementById('cost-1').innerText = cost;
        if (gameState.money >= cost) p1Btn.disabled = false;
    } else { document.getElementById('path-1-desc').innerText = "Path Locked"; }

    if (selectedTower.path === 0 || selectedTower.path === 2) {
        const upg = info.upgrades.path2[selectedTower.level];
        const cost = Math.floor(upg.cost * discountMult);
        document.getElementById('path-2-desc').innerText = upg.name + ": " + upg.desc;
        document.getElementById('cost-2').innerText = cost;
        if (gameState.money >= cost) p2Btn.disabled = false;
    } else { document.getElementById('path-2-desc').innerText = "Path Locked"; }
}

function buyUpgrade(pathIdx) {
    if (!selectedTower) return;
    const info = TOWER_TYPES[selectedTower.type];
    const upgradeList = pathIdx === 1 ? info.upgrades.path1 : info.upgrades.path2;
    const upgrade = upgradeList[selectedTower.level]; 
    const discountMult = selectedTower.buffCostMultiplier || 1.0;
    const finalCost = Math.floor(upgrade.cost * discountMult);

    if (gameState.money >= finalCost) {
        gameState.money -= finalCost;
        selectedTower.path = pathIdx;
        selectedTower.level++;
        if (selectedTower.type === 'sentry' && pathIdx === 1) selectedTower.cooldownMax *= 0.8;
        if (selectedTower.type === 'sentry' && pathIdx === 2) selectedTower.damage += 10;
        updateUI(); updateUpgradeMenu();
    }
}

function sellSelectedTower() {
    if (!selectedTower) return;
    gameState.money += Math.floor(TOWER_TYPES[selectedTower.type].cost * 0.7); 
    const idx = towers.indexOf(selectedTower);
    if (idx > -1) towers.splice(idx, 1);
    selectedTower = null; updateUI(); updateUpgradeMenu();
}

function closeUpgradeMenu() { selectedTower = null; updateUpgradeMenu(); }
function endGame() { gameState.gameOver = true; document.getElementById('game-over').style.display = "flex"; }

function selectMap(index) {
    if (index >= gameState.unlockedMaps) return; // Locked
    Sound.init(); 
    gameState.mapIndex = index;
    pathPoints = MAPS[index].points;
    document.getElementById('map-screen').style.display = 'none';
    
    // Reset Game State for new level
    gameState.money = 300;
    gameState.lives = 100;
    gameState.wave = 1;
    gameState.isPlaying = false;
    gameState.gameOver = false;
    gameState.endless = false;
    towers = []; enemies = []; projectiles = []; particles = []; mines = []; visualEffects = [];
    updateUI();
}

function renderMapSelection() {
    const container = document.getElementById('map-grid-container');
    container.innerHTML = '';
    MAPS.forEach((map, idx) => {
        const isLocked = idx >= gameState.unlockedMaps;
        const card = document.createElement('div');
        card.className = 'map-card' + (isLocked ? ' locked' : '');
        card.onclick = () => selectMap(idx);
        
        let html = `<div class="map-name">${map.name}</div>
                    <div class="map-diff">${map.diffName} (Limit: ${map.waveLimit})</div>`;
        
        if (isLocked) {
            html += `<div class="lock-icon">🔒</div>`;
        } else {
            html += `<div class="map-preview" style="${map.previewStyle}"></div>`;
        }
        card.innerHTML = html;
        container.appendChild(card);
    });
}

function completeLevel() {
    document.getElementById('level-complete').style.display = 'flex';
    // Unlock next map
    if (gameState.mapIndex + 1 >= gameState.unlockedMaps && gameState.mapIndex + 1 < MAPS.length) {
        gameState.unlockedMaps = gameState.mapIndex + 2; // +1 for next index, +1 for count logic
        localStorage.setItem('tad_unlocked', gameState.unlockedMaps);
    }
}

function returnToMenu() {
    document.getElementById('level-complete').style.display = 'none';
    document.getElementById('map-screen').style.display = 'flex';
    renderMapSelection();
}

function continueEndless() {
    document.getElementById('level-complete').style.display = 'none';
    gameState.endless = true;
    startNextWave();
}

canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect(); mousePos.x = e.clientX - rect.left; mousePos.y = e.clientY - rect.top;
});

canvas.addEventListener('mousedown', (e) => {
    if (gameState.gameOver) return;
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top;

    if (gameState.activeAbility) {
        useActiveAbility(mouseX, mouseY);
        return;
    }

    if (buildMode) {
        const typeInfo = TOWER_TYPES[buildMode];
        if (gameState.money >= typeInfo.cost) {
            if (!isNearPath(mouseX, mouseY) && !isNearTower(mouseX, mouseY)) {
                gameState.money -= typeInfo.cost;
                towers.push(new Tower(mouseX, mouseY, buildMode));
                particles.push(new Particle(mouseX, mouseY, "#fff", 10, 20));
                buildMode = null;
                document.querySelectorAll('.tower-card').forEach(c => c.classList.remove('selected'));
                canvas.style.cursor = 'default';
                updateUI(); refreshShopAffordability();
            }
        }
    } else {
        selectedTower = null;
        for (const t of towers) { if (Math.hypot(t.x - mouseX, t.y - mouseY) < 20) { selectedTower = t; break; } }
        updateUpgradeMenu();
    }
});

function isNearPath(x, y) {
    for(let i=0; i<pathPoints.length-1; i++) {
        const p1 = pathPoints[i]; const p2 = pathPoints[i+1];
        const A = x - p1.x; const B = y - p1.y; const C = p2.x - p1.x; const D = p2.y - p1.y;
        const dot = A * C + B * D; const lenSq = C * C + D * D;
        let param = -1; if (lenSq != 0) param = dot / lenSq;
        let xx, yy;
        if (param < 0) { xx = p1.x; yy = p1.y; } else if (param > 1) { xx = p2.x; yy = p2.y; } else { xx = p1.x + param * C; yy = p1.y + param * D; }
        const dx = x - xx; const dy = y - yy;
        if (Math.hypot(dx, dy) < 30) return true; 
    }
    return false;
}

function isNearTower(x, y) {
    for(const t of towers) { if(Math.hypot(t.x - x, t.y - y) < 40) return true; }
    return false;
}

// --- Wave Logic ---
let enemiesToSpawn = [];
let spawnTimer = 0;
let waveInProgress = false;

function startNextWave() {
    if (waveInProgress) return;
    waveInProgress = true;
    document.getElementById('start-wave-btn').disabled = true;
    document.getElementById('start-wave-btn').style.opacity = 0.5;

    const w = gameState.wave;
    const count = Math.floor(5 + Math.pow(w, 1.4)); 
    enemiesToSpawn = [];
    
    let bossType = null;
    if (w % 20 === 0) bossType = 'titan_mk2';
    else if (w % 10 === 0) bossType = 'boss';
    else if (w % 5 === 0) bossType = 'centurion';

    for(let i=0; i<count; i++) {
        if (bossType && i === count - 1) { enemiesToSpawn.push(bossType); continue; }
        
        const rand = Math.random();
        let type = 'basic';
        
        if (w < 3) type = 'basic';
        else if (w < 10) {
            if (rand < 0.2) type = 'fast'; else if (rand < 0.25) type = 'swarm'; else type = 'basic';
        } else if (w < 20) {
            if (rand < 0.05) type = 'tank'; else if (rand < 0.1) type = 'regen'; else if (rand < 0.3) type = 'fast'; else type = 'basic';
        } else if (w < 40) {
             if (rand < 0.1) type = 'phase'; else if (rand < 0.2) type = 'shield'; else if (rand < 0.5) type = 'swarm'; else type = 'fast';
        } else {
             if (rand < 0.05) type = 'elite'; else if (rand < 0.1) type = 'diamond'; else if (rand < 0.15) type = 'dark_matter'; else if (rand < 0.3) type = 'shield'; else type = 'swarm'; 
        }
        
        // Add flyer chance based on wave
        if (w > 5 && Math.random() < 0.1) type = 'flyer';

        enemiesToSpawn.push(type);
    }
}

function updateGameLogic() {
    // Ability Cooldowns
    if (gameState.abilities.laser.cd > 0) gameState.abilities.laser.cd--;
    if (gameState.abilities.freeze.cd > 0) gameState.abilities.freeze.cd--;
    if (gameState.freezeTimer > 0) gameState.freezeTimer--;

    if (waveInProgress) {
        spawnTimer++;
        let spawnRate = Math.max(10, 60 - (gameState.wave * 1.5));
        if (spawnTimer > spawnRate) { 
            if (enemiesToSpawn.length > 0) { enemies.push(new Enemy(enemiesToSpawn.shift())); spawnTimer = 0; }
            else if (enemies.length === 0) {
                waveInProgress = false;
                
                // Check Level Limit
                if (!gameState.endless && gameState.wave >= MAPS[gameState.mapIndex].waveLimit) {
                    completeLevel();
                    return;
                }

                const waveBonus = 100 + (gameState.wave * 10);
                gameState.money += waveBonus;
                towers.forEach(t => t.onWaveEnd());
                gameState.wave++;
                
                if (gameState.autoStart) {
                    setTimeout(() => startNextWave(), 1000);
                } else {
                    document.getElementById('start-wave-btn').disabled = false;
                    document.getElementById('start-wave-btn').style.opacity = 1;
                }
                updateUI();
            }
        }
    }
    towers.forEach(t => { t.update(); t.act(); });
    enemies.forEach(e => e.update());
    projectiles.forEach(p => p.update());
    particles.forEach(p => p.update());
    for(let i=visualEffects.length-1; i>=0; i--) {
        visualEffects[i].update();
        if(visualEffects[i].life <= 0) visualEffects.splice(i, 1);
    }
    for (let i = mines.length - 1; i >= 0; i--) {
        let m = mines[i];
        m.life--;
        let hit = false;
        for (let e of enemies) {
            if (Math.hypot(e.x - m.x, e.y - m.y) < m.radius) {
                hit = true;
                e.takeDamage(m.damage, m.source);
                if (m.type === 'rune') e.slowTimer = 30;
                visualEffects.push(new VisualEffect('explosion', m.x, m.y, { radius: 15, color: m.type==='tech'?'#f00':'#0ff', life: 10 }));
                break; 
            }
        }
        if (hit || m.life <= 0) mines.splice(i, 1);
    }
    projectiles = projectiles.filter(p => p.active);
    particles = particles.filter(p => p.life > 0);
}

function drawGame() {
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    // Draw Path
    if (pathPoints.length > 0) {
        ctx.beginPath();
        ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
        for(let i=1; i<pathPoints.length; i++) ctx.lineTo(pathPoints[i].x, pathPoints[i].y);
        ctx.lineCap = "round"; ctx.lineJoin = "round";
        ctx.lineWidth = GRID_SIZE; ctx.strokeStyle = C_PATH_BORDER; ctx.stroke();
        ctx.lineWidth = GRID_SIZE - 4; ctx.strokeStyle = C_PATH; ctx.stroke();
        ctx.lineWidth = 2; ctx.setLineDash([10, 20]); ctx.strokeStyle = "rgba(0, 243, 255, 0.1)"; ctx.stroke(); ctx.setLineDash([]);

        // Draw Wormhole for Wrinklings
        if (enemies.some(e => e.fly)) {
            const start = pathPoints[0];
            const end = pathPoints[pathPoints.length - 1];
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            
            // Visuals
            ctx.shadowBlur = 15;
            ctx.shadowColor = "#9370DB"; // MediumPurple glow
            ctx.lineWidth = 14;
            ctx.strokeStyle = "rgba(75, 0, 130, 0.2)"; // Faint indigo tunnel
            ctx.stroke();
            
            ctx.shadowBlur = 0;
            ctx.lineWidth = 3;
            ctx.strokeStyle = "rgba(147, 112, 219, 0.8)"; // Moving texture
            ctx.setLineDash([15, 15]);
            ctx.lineDashOffset = -gameState.frames * 3; // Animation
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.restore();
        }
    }

    mines.forEach(m => {
        ctx.fillStyle = (m.type === 'tech') ? '#ff0000' : '#00ffff';
        ctx.beginPath(); ctx.arc(m.x, m.y, 4, 0, Math.PI*2); ctx.fill();
    });

    towers.forEach(t => t.draw());
    enemies.forEach(e => e.draw());
    projectiles.forEach(p => p.draw());
    particles.forEach(p => p.draw(ctx));
    visualEffects.forEach(v => v.draw(ctx));

    // Freeze overlay
    if (gameState.freezeTimer > 0) {
        ctx.fillStyle = "rgba(0, 255, 255, 0.1)";
        ctx.fillRect(0,0,CANVAS_WIDTH, CANVAS_HEIGHT);
    }

    if (buildMode || gameState.activeAbility === 'laser') {
         ctx.save(); ctx.translate(mousePos.x, mousePos.y);
         
         if (gameState.activeAbility === 'laser') {
             ctx.beginPath(); ctx.arc(0,0,60,0,Math.PI*2);
             ctx.fillStyle = "rgba(255, 50, 50, 0.3)"; ctx.strokeStyle = "red";
             ctx.fill(); ctx.stroke();
         } else {
             const type = TOWER_TYPES[buildMode];
             const validPos = !isNearPath(mousePos.x, mousePos.y) && !isNearTower(mousePos.x, mousePos.y);
             const canAfford = gameState.money >= type.cost;
             
             ctx.beginPath(); ctx.arc(0, 0, type.range, 0, Math.PI * 2);
             if (validPos && canAfford) { ctx.fillStyle = "rgba(255, 255, 255, 0.2)"; ctx.strokeStyle = "rgba(255, 255, 255, 0.5)"; }
             else { ctx.fillStyle = "rgba(255, 0, 0, 0.4)"; ctx.strokeStyle = "rgba(255, 0, 0, 0.8)"; }
             ctx.fill(); ctx.stroke();
         }
         ctx.restore();
    }
}

function gameLoop() {
    if (gameState.gameOver) return;
    // Don't update if map not selected yet (though UI layer covers canvas)
    if (pathPoints.length > 0) {
        for(let i=0; i<gameState.gameSpeed; i++) updateGameLogic();
        updateUI(); drawGame();
    }
    gameState.frames++;
    requestAnimationFrame(gameLoop);
}

function init() {
    renderMapSelection();
    // Only init UI, gameLoop will run but logic paused by pathPoints check
    gameLoop();
}

if (document.readyState === 'complete' || document.readyState === 'interactive') {
    init();
} else {
    window.addEventListener('load', init);
}
</script>
</body>
</html>